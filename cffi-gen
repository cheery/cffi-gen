#!/usr/bin/env python
from sys import argv, exit
from subprocess import check_output
from tokenizer import tokenize
import re
import lrkit
import operator
from lrkit import canonical, Rule, Accept

class Signed(object):
    def __init__(self, size):
        self.size = size

    def __repr__(self, size):
        return "s%i" % size

class Unsigned(object):
    def __init__(self, size):
        self.size = size

    def __repr__(self, size):
        return "u%i" % size

class Float(object):
    def __init__(self, size):
        self.size = size

    def __repr__(self, size):
        return "f%i" % size

class Pointer(object):
    def __init__(self, tp):
        self.tp = tp

    def __repr__(self):
        return repr(self.tp) + '*'

class Structure(object):
    def __init__(self, fields):
        self.fields = fields

class Union(object):
    def __init__(self, fields):
        self.fields = fields

def reset_env():
    global prim_space, enum_space, union_space, struct_space, type_space, name_space, mode_types
    prim_space = {
        'pointer': Signed(8),
        'enum': Signed(4),
        'char': Unsigned(1),
        'short': Signed(2),
        'short int': Signed(2),
        'int': Signed(4),
        'long': Signed(8),
        'long int': Signed(8),
        'long unsigned int': Unsigned(8),
        'long long int': Signed(8),
        'float': Float(4),
        'double': Float(8),
        'long double': Float(16),
    }

    enum_space = {}
    union_space = {}
    struct_space = {
        '__locale_data': Structure(None),
    }

    type_space = {
        '__builtin_va_list': Pointer(Structure(None)),
        'void': None,
    }

    name_space = {
    }

    mode_types = {
            '__QI__': Signed(1),
            '__HI__': Signed(2),
            '__SI__': Signed(4),
            '__DI__': Signed(8),
            '__word__': Signed(4),
    }

rules = []
labelled_rules = {}

def rule(string, label=None):
    lhs, rhs = string.split(' = ')
    rule = Rule(lhs.strip(), [a for a in rhs.strip().split(' ') if len(a) > 0])
    if label is not None:
        labelled_rules[label] = rule
    def _impl_(func):
        rule.func = func
        return func
    rules.append(rule)
    return _impl_

@rule('translation_unit = ')
@rule('blank_list = ')
def on_blank_list(lineno):
    return []

@rule('blank = ')
def on_blank(lineno):
    return None

@rule('declaration_list = declaration')
@rule('init_declarator_list = init_declarator')
@rule('initializer_list = initializer')
@rule('identifier_list = IDENTIFIER')
@rule('parameter_list = parameter_declaration')
@rule('struct_declaration_list = struct_declaration')
@rule('struct_declarator_list = struct_declarator')
@rule('enumerator_list = enumerator')
@rule('specifier_qualifier_list = specifier_qualifier')
@rule('declaration_specifiers = declaration_specifier')
@rule('type_qualifier_list = type_qualifier')
@rule('attribute_specifier_list = attribute_specifier', label="declarator_attribute")
@rule('attribute_list = attribute')
def on_list(lineno, obj):
    return [obj]

@rule('translation_unit = translation_unit external_declaration')
@rule('declaration_list = declaration_list declaration')
@rule('struct_declaration_list = struct_declaration_list struct_declaration')
@rule('specifier_qualifier_list = specifier_qualifier_list specifier_qualifier')
@rule('declaration_specifiers = declaration_specifiers declaration_specifier')
@rule('type_qualifier_list = type_qualifier_list type_qualifier')
@rule('attribute_specifier_list = attribute_specifier_list attribute_specifier')
def on_append(lineno, seq, obj):
    seq.append(obj)
    return seq

@rule('init_declarator_list = init_declarator_list COMMA init_declarator')
@rule('initializer_list = initializer_list COMMA initializer')
@rule('identifier_list = identifier_list COMMA IDENTIFIER')
@rule('parameter_list = parameter_list COMMA parameter_declaration')
@rule('struct_declarator_list = struct_declarator_list COMMA struct_declarator')
@rule('enumerator_list = enumerator_list COMMA enumerator')
@rule('attribute_list = attribute_list COMMA attribute')
def on_separator_append(lineno, seq, sep, obj):
    seq.append(obj)
    return seq

@rule('external_declaration = function_definition')
@rule('external_declaration = declaration')
def on_passthrough(lineno, obj):
    return obj

@rule('declaration = declaration_specifiers blank_list SEMICOLON')
@rule('declaration = declaration_specifiers init_declarator_list SEMICOLON')
def on_declaration(lineno, specifiers, declarators, *sm):
    if 'typedef' in specifiers:
        for declarator in declarators:
            assert isinstance(declarator, Declarator)
            type_space[declarator.name] = declarator
    return specifiers, declarators

@rule('function_definition = declaration_specifiers declarator declaration_list compound_statement')
@rule('function_definition = declaration_specifiers declarator attribute_specifier_list compound_statement')
@rule('function_definition = declaration_specifiers declarator compound_statement')
@rule('function_definition = declarator declaration_list compound_statement')
@rule('function_definition = declarator attribute_specifier_list compound_statement')
@rule('function_definition = declarator compound_statement')
def on_function_definition(lineno, *stuff):
    return stuff

class Declarator(object):
    def __init__(self, name):
        self.name = name
        self.initializer = None
        self.attributes = None

@rule('direct_declarator = IDENTIFIER')
def on_direct_declarator_simple(lineno, declarator):
    return Declarator(declarator)

@rule('direct_declarator = LEFT_PAREN declarator RIGHT_PAREN')
def on_pointer_declarator_simple(lineno, lp, declarator, rp):
    return declarator

@rule('direct_declarator = direct_declarator LEFT_BRACKET RIGHT_BRACKET')
@rule('direct_declarator = direct_declarator LEFT_BRACKET constant_expression RIGHT_BRACKET')
@rule('direct_declarator = direct_declarator LEFT_PAREN parameter_type_list RIGHT_PAREN')
@rule('direct_declarator = direct_declarator LEFT_PAREN identifier_list RIGHT_PAREN')
@rule('direct_declarator = direct_declarator LEFT_PAREN RIGHT_PAREN')
def on_direct_declarator(lineno, *stuff):
    return stuff[0]

@rule('parameter_type_list = parameter_list')
@rule('parameter_type_list = parameter_list COMMA DOT DOT DOT')
def on_parameter_type_list(lineno, parameters, *ellipsis):
    has_ellipsis = len(ellipsis) > 0
    return parameters, has_ellipsis

@rule('parameter_declaration = declaration_specifiers declarator')
@rule('parameter_declaration = declaration_specifiers abstract_declarator')
@rule('parameter_declaration = declaration_specifiers')
def on_parameter_declaration(lineno, specifiers, parameter=None):
    return specifiers, parameter

@rule('abstract_declarator = pointer')
@rule('abstract_declarator = direct_abstract_declarator')
@rule('abstract_declarator = pointer direct_abstract_declarator')
@rule('direct_abstract_declarator = LEFT_PAREN abstract_declarator RIGHT_PAREN')
@rule('direct_abstract_declarator = LEFT_BRACKET RIGHT_BRACKET')
@rule('direct_abstract_declarator = LEFT_BRACKET constant_expression RIGHT_BRACKET')
@rule('direct_abstract_declarator = direct_abstract_declarator LEFT_BRACKET RIGHT_BRACKET')
@rule('direct_abstract_declarator = direct_abstract_declarator LEFT_BRACKET constant_expression RIGHT_BRACKET')
@rule('direct_abstract_declarator = direct_abstract_declarator LEFT_PAREN RIGHT_PAREN')
@rule('direct_abstract_declarator = direct_abstract_declarator LEFT_PAREN parameter_type_list RIGHT_PAREN')
def on_abstract_declarator(lineno, *stuff):
    return stuff


@rule('declaration_specifier = storage_class_specifier')
@rule('declaration_specifier = type_specifier')
@rule('declaration_specifier = type_qualifier')
def on_declaration_specifier(lineno, specifier):
    return specifier
#@rule('declaration_specifiers = storage_class_specifier')
#@rule('declaration_specifiers = declaration_specifiers storage_class_specifier')
##@rule('declaration_specifiers = specifier_qualifier_list')
#@rule('declaration_specifiers = type_specifier')
#@rule('declaration_specifiers = type_specifier declaration_specifiers')
#@rule('declaration_specifiers = type_qualifier')
#@rule('declaration_specifiers = type_qualifier declaration_specifiers')
#def on_declaration_specifiers(lineno, specifier, rest=()):
#    return [specifier] + list(rest)

#@rule('function_specifiers = declaration_specifiers')
#def on_function_specifiers(lineno, specifier, attrib=None, rest=()):
#    if attrib is not None:
#        return specifier + [attrib] + list(rest)
#    else:
#        return specifier

@rule('specifier_qualifier = type_specifier')
@rule('specifier_qualifier = type_qualifier')
def on_specifier_qualifier(lineno, specifier):
    return specifier

#@rule('specifier_qualifier_list = type_specifier')
#@rule('specifier_qualifier_list = type_specifier specifier_qualifier_list')
#@rule('specifier_qualifier_list = type_qualifier')
#@rule('specifier_qualifier_list = type_qualifier specifier_qualifier_list')
#def on_declaration_specifiers(lineno, specifier, rest=()):
#    return [specifier] + list(rest)

#@rule('attribute_specifier = LOL')
#def on_attribute_specifier(lineno, at):
#    return None

@rule('attribute_specifier = __ASM__ LEFT_PAREN attribute_list RIGHT_PAREN')
def on_attribute_specifier(lineno, at, lp1, attributes, rp2):
    return ('asm', attributes)

@rule('attribute_specifier = __ATTRIBUTE__ LEFT_PAREN LEFT_PAREN attribute_list RIGHT_PAREN RIGHT_PAREN')
def on_attribute_specifier(lineno, at, lp1, lp2, attributes, rp1, rp2):
    return ('attribute', attributes)

@rule('attribute = STRING')
@rule('attribute = STRING STRING')
@rule('attribute = IDENTIFIER')
@rule('attribute = INTCONSTANT')
@rule('attribute = IDENTIFIER LEFT_PAREN attribute_list RIGHT_PAREN')
def on_attribute(lineno, *stuff):
    return stuff

#@rule('storage_class_specifier = attribute_specifier')
@rule('storage_class_specifier = attribute_specifier', label="storage_attribute")
@rule('storage_class_specifier = TYPEDEF')
@rule('storage_class_specifier = EXTERN')
@rule('storage_class_specifier = STATIC')
@rule('storage_class_specifier = AUTO')
@rule('storage_class_specifier = REGISTER')
@rule('storage_class_specifier = INLINE')
@rule('storage_class_specifier = __INLINE')
@rule('storage_class_specifier = __INLINE__')
@rule('storage_class_specifier = __THREAD')
def on_storage_class_specifier(lineno, specifier):
    return specifier

@rule('type_specifier = VOID')
@rule('type_specifier = CHAR')
@rule('type_specifier = SHORT')
@rule('type_specifier = INT')
@rule('type_specifier = LONG')
@rule('type_specifier = FLOAT')
@rule('type_specifier = DOUBLE')
@rule('type_specifier = SIGNED')
@rule('type_specifier = UNSIGNED')
@rule('type_specifier = struct_or_union_specifier')
@rule('type_specifier = enum_specifier')
@rule('type_specifier = TYPE_NAME')
def on_type_specifier(lineno, specifier):
    return specifier

@rule('type_qualifier = CONST')
@rule('type_qualifier = VOLATILE')
@rule('type_qualifier = __RESTRICT')
@rule('type_qualifier = __EXTENSION__')
def on_type_qualifier(lineno, qualifier):
    return qualifier

@rule('init_declarator = declarator attribute_specifier_list')
@rule('init_declarator = declarator')
def on_init_declarator(lineno, declarator, attributes=()):
    declarator.attributes = attributes
    return declarator

@rule('init_declarator = declarator EQUAL initializer')
def on_init_declarator_init(lineno, declarator, eq, initializer):
    declarator.initializer = initializer
    return (declarator, initializer)

# test verified attribute is not a declarator
#@rule('declarator = pointer direct_declarator LOL')
#@rule('declarator = direct_declarator LOL')
#def on_declarator_attribute(lineno, pointer, declarator):
#    return [pointer, declarator]

@rule('declarator = pointer direct_declarator')
def on_declarator_pointer(lineno, pointer, declarator):
    # mark the pointer somehow
    return declarator

@rule('declarator = direct_declarator')
def on_declarator(lineno, declarator):
    return declarator

@rule('initializer = assignment_expression')
def on_initializer_assignment_expression(lineno, expr):
    return expr

@rule('initializer = LEFT_BRACE initializer_list RIGHT_BRACE')
@rule('initializer = LEFT_BRACE initializer_list COMMA RIGHT_BRACE')
def on_initializer_list(lineno, lb, initlist, *rest):
    return initlist

@rule('pointer = STAR')
@rule('pointer = STAR pointer')
def on_pointer_with_no_qualifiers(lineno, star, pointer=None):
    return ('*', (), pointer)
@rule('pointer = STAR type_qualifier_list')
@rule('pointer = STAR type_qualifier_list pointer')
def on_pointer_with_qualifiers(lineno, star, type_qualifier, pointer=None):
    return ('*', type_qualifier, pointer)

@rule('struct_or_union_specifier = struct_or_union struct_identifier LEFT_BRACE struct_declaration_list RIGHT_BRACE')
@rule('struct_or_union_specifier = struct_or_union LEFT_BRACE struct_declaration_list RIGHT_BRACE')
@rule('struct_or_union_specifier = struct_or_union struct_identifier')
def on_struct_or_union_specifier(lineno, which, *rest):
    return which, rest

@rule('struct_identifier = IDENTIFIER')
@rule('struct_identifier = TYPE_NAME')
def on_struct_identifier(lineno, name):
    return name

@rule('struct_or_union = STRUCT')
@rule('struct_or_union = UNION')
def on_struct_or_union(lineno, which):
    return which

@rule('struct_declaration = specifier_qualifier_list struct_declarator_list SEMICOLON')
def on_struct_declaration(lineno, specifier, declarator, sm):
    return specifier, declarator

@rule('struct_declarator = declarator')
@rule('struct_declarator = COLON constant_expression')
@rule('struct_declarator = declarator COLON constant_expression')
def on_struct_declarator(lineno, *stuff):
    return stuff

@rule('enum_specifier = ENUM LEFT_BRACE enumerator_list RIGHT_BRACE')
@rule('enum_specifier = ENUM IDENTIFIER LEFT_BRACE enumerator_list RIGHT_BRACE')
@rule('enum_specifier = ENUM IDENTIFIER')
def on_enum_specifier(lineno, *stuff):
    return stuff

@rule('enumerator = IDENTIFIER')
@rule('enumerator = IDENTIFIER EQUAL constant_expression')
def on_enumerator(lineno, *stuff):
    return stuff

@rule('compound_statement = LEFT_BRACE RIGHT_BRACE')
@rule('compound_statement = LEFT_BRACE statement_list RIGHT_BRACE')
#@rule('compound_statement = LEFT_BRACE declaration_list RIGHT_BRACE')
@rule('statement_list = statement')
@rule('statement_list = statement_list statement')
@rule('statement = compound_statement')
@rule('statement = *')
def on_ignore_it_all(lineno, *ignore):
    return None

@rule('constant_expression = constant_comparison QUESTION constant_comparison COLON constant_comparison')
def on_const_comparison(lineno, cond, q, tru, c, fal):
    return [tru, fal][cond]

@rule('constant_expression = constant_bitor')
@rule('constant_bitor = constant_comparison')
@rule('constant_comparison = constant_shift')
@rule('constant_shift = constant_plusminus')
@rule('constant_plusminus = constant_divmul')
@rule('constant_divmul = constant_term')
def on_const_expression(lineno, value):
    return value

@rule('constant_bitor = constant_bitor VERTICAL_BAR constant_comparison')
@rule('constant_comparison = constant_comparison LEFT_ANGLE constant_shift')
@rule('constant_comparison = constant_comparison RIGHT_ANGLE constant_shift')
@rule('constant_comparison = constant_comparison EQ_OP constant_shift')
@rule('constant_shift = constant_shift LEFT_OP constant_plusminus')
@rule('constant_shift = constant_shift RIGHT_OP constant_plusminus')
@rule('constant_plusminus = constant_plusminus PLUS constant_divmul')
@rule('constant_plusminus = constant_plusminus DASH constant_divmul')
@rule('constant_divmul = constant_divmul SLASH constant_term')
@rule('constant_divmul = constant_divmul STAR constant_term')
def on_const_binop(lineno, lhs, op, rhs):
    value = {
        '|':operator.or_,
        '==':operator.eq,
        '<<':operator.lshift,
        '>>':operator.rshift,
        '<':operator.lt,
        '>':operator.gt,
        '/':operator.div,
        '*':operator.mul,
        '-':operator.sub,
        '+':operator.add,
    }[op](lhs, rhs)
    return value

@rule('constant_term = IDENTIFIER')
def on_minus_prefix(lineno, value):
    return 0

@rule('constant_term = CHARACTER')
def on_minus_prefix(lineno, value):
    return ord(value[1])

@rule('constant_term = PLUS constant_term')
def on_plus_prefix(lineno, dash, value):
    return +value

@rule('constant_term = DASH constant_term')
def on_minus_prefix(lineno, dash, value):
    return -value

@rule('constant_term = LEFT_PAREN constant_expression RIGHT_PAREN')
def on_int_constant(lineno, lp, value, rp):
    return value

@rule('constant_term = SIZEOF LEFT_PAREN type_expression RIGHT_PAREN')
def on_sizeof_term(lineno, sz, lp, typesign, rp):
    return 8
#    if isinstance(typesign, Pointer):
#        return prim_space['pointer'].size
#    assert typesign is not None, "%i: null type" % lineno
#    return typesign.size
#
@rule('constant_term = LEFT_PAREN type_expression RIGHT_PAREN constant_term')
def on_sizeof_term(lineno, lp, typesign, rp, ct):
    return ct

@rule('constant_term = INTCONSTANT')
def on_constant_expression_int(lineno, const):
    if const.lower().endswith('u'):
        const = const.lower().rstrip('u')
    if const.startswith('0x') or const.startswith('0X'):
        return int(const, 16)
    return int(const)

@rule('type_expression = specifier_qualifier_list')
@rule('type_expression = specifier_qualifier_list pointer')
def on_type_expression(lineno, *rest):
    return rest

#@rule('struct-list = ')
#@rule('argument-list = ')
#@rule('type-prefixes = ')
#@rule('enum-list = ')
#def on_blank_list(lineno):
#    return []
#
#@rule('header-file = declaration')
#@rule('argument-list = argument')
#@rule('enum-list = enum-name')
#def on_list(lineno, obj):
#    return [obj]
#
#@rule('header-file = header-file declaration')
#@rule('struct-list = struct-list record-field')
#@rule('type-prefixes = type-prefixes VOLATILE')
#def on_append(lineno, seq, obj):
#    seq.append(obj)
#    return seq
#
#@rule('argument-list = argument-list COMMA argument')
#@rule('enum-list = enum-list COMMA enum-name')
#def on_append_2(lineno, seq, sep, obj):
#    seq.append(obj)
#    return seq
#
#@rule('header-file = header-file __EXTENSION__')
#@rule('header-file = header-file EXTERN')
#@rule('header-file = header-file by-the-way')
#@rule('header-file = header-file attribute-clause')
#@rule('struct-list = struct-list MACRO')
#@rule('struct-list = struct-list __EXTENSION__')
#@rule('by-the-way = struct-union-header SEMICOLON')
#def on_ignore(lineno, seq, *crap):
#    return seq
#
##@rule('declaration = MACRO')
##def on_macro(lineno, macro):
##    return ('MACRO', macro)
#
#@rule('by-the-way = TYPEDEF type-prefixes type-sign IDENTIFIER attribute-clauses SEMICOLON')
#def on_typedef(lineno, td, prefix, typesign, identifier, clauses, sm):
#    type_space[identifier] = typesign
#
## must still parse __mode__
##@rule('by-the-way = TYPEDEF type-prefixes type-sign IDENTIFIER __ATTRIBUTE__ LEFT_PAREN LEFT_PAREN __MODE__ LEFT_PAREN IDENTIFIER RIGHT_PAREN RIGHT_PAREN RIGHT_PAREN SEMICOLON')
##def on_typedef_structure(lineno, td, tp, i, name, at, lp1, lp2, md, lp3, ident, rp1, rp2, rp3, sm):
##    assert ident in mode_types, "%i: unknown mode(%s)" % (lineno, ident)
##    type_space[name] = mode_types[ident]
#
#@rule('by-the-way = TYPEDEF type-prefixes type-sign IDENTIFIER LEFT_BRACKET const-expression RIGHT_BRACKET SEMICOLON')
#def on_array_thingy(lineno, td, tp, typesign, name, lb, value, rb, sm):
#    type_space[name] = ('array', typesign, value)
#
#@rule('by-the-way = TYPEDEF type-prefixes type-sign IDENTIFIER LEFT_PAREN argument-list RIGHT_PAREN SEMICOLON')
#def on_function_pointer(lineno, td, tp, restype, name, lp, argtypes, rp, sm):
#    type_space[name] = ('functype', restype, argtypes)
#
#@rule('by-the-way = TYPEDEF type-prefixes type-sign LEFT_PAREN STAR IDENTIFIER RIGHT_PAREN LEFT_PAREN argument-list RIGHT_PAREN SEMICOLON')
#def on_function_pointer2(lineno, td, tp, restype, lp, st, name, rp, lp2, argtypes, rp2, sm):
#    type_space[name] = ('functype', restype, argtypes)
#
#@rule('by-the-way = STATIC inline-mark type-sign IDENTIFIER LEFT_PAREN argument-list RIGHT_PAREN LEFT_BRACE trash-brace-block RIGHT_BRACE')
#@rule('trash-brace-block = ')
#@rule('trash-brace-block = trash-brace-block *')
#@rule('trash-brace-block = trash-brace-block LEFT_BRACE trash-brace-block RIGHT_BRACE')
#@rule('inline-mark = __INLINE')
#@rule('inline-mark = INLINE')
#def on_inline_statement(lineno, *trash):
#    pass
#
#
##@rule('declaration = name-pair SEMICOLON')
##def on_global_value(lineno, pair, sm):
##    return ('GLOBAL', pair[0], pair[1])
#
##@rule('declaration = type-sign IDENTIFIER LEFT_PAREN argument-list RIGHT_PAREN attribute-clauses SEMICOLON')
##def on_function(lineno, restype, name, lp, argtypes, rp, blah, sm):
##    return ('FUNCTION', name, (restype, argtypes))
#
#@rule('record-field = name-pair SEMICOLON')
#def on_record_field(lineno, pair, sm):
#    return pair
#
#@rule('argument = type-sign')
#@rule('argument = type-sign IDENTIFIER')
#@rule('argument = type-sign __RESTRICT')
#@rule('argument = type-sign __RESTRICT IDENTIFIER')
#def on_function_argument(lineno, typesign, *blah):
#    return typesign
#
#@rule('argument = DOT DOT DOT')
#def on_function_dot_dot_dot(lineno, dot1, dot2, dot3):
#    return None
#
#@rule('argument = argument LEFT_BRACKET RIGHT_BRACKET')
#def on_arb_array_argument(lineno, argtype, lb, rb):
#    return ('array', argtype, None)
#
#@rule('argument = argument LEFT_BRACKET const-expression RIGHT_BRACKET')
#def on_array_argument(lineno, argtype, lb, count, rb):
#    assert isinstance(count, int)
#    return ('array', argtype, count)
#
#@rule('argument = type-sign LEFT_PAREN STAR IDENTIFIER RIGHT_PAREN LEFT_PAREN argument-list RIGHT_PAREN')
#def on_functype_argument(lineno, restype, lp, st, name, rp, lp2, argtypes, rp2):
#    return ('functypen', restype, argtypes)
#
##@rule('name-pair = type-sign __RESTRICT IDENTIFIER')
##def on_name_restrict_pair(lineno, typesign, rs, name):
##    return (name, typesign)
#
#@rule('name-pair = type-sign IDENTIFIER COLON INTCONSTANT')
#def on_bit_horror(lineno, typesign, name, c, bitc):
#    return (name, ('bits', typesign, int(bitc)))
#
#@rule('name-pair = type-sign COLON INTCONSTANT')
#def on_more_bit_horror(lineno, typesign, c, bitc):
#    return (None, ('bits', typesign, int(bitc)))
#
#@rule('name-pair = type-sign IDENTIFIER')
#def on_name_pair(lineno, typesign, name):
#    return (name, typesign)
##
##@rule('name-pair = type-sign CONST IDENTIFIER')
##def on_name_pair_const(lineno, typesign, const, name):
##    return (name, typesign)
#
#@rule('name-pair = name-pair LEFT_BRACKET RIGHT_BRACKET')
#def on_arb_array_field(lineno, pair, lb, rb):
#    name, typesign = pair
#    return (name, ('array', typesign, None))
#
#@rule('name-pair = name-pair LEFT_BRACKET const-expression RIGHT_BRACKET')
#def on_array_field(lineno, pair, lb, count, rb):
#    name, typesign = pair
#    assert isinstance(count, int)
#    return (name, ('array', typesign, count))
#
#@rule('struct-union-header = UNION')
#def on_unnamed_union_header(lineno, st):
#    return Union(None)
#
#@rule('struct-union-header = STRUCT')
#def on_unnamed_struct_header(lineno, st):
#    return Structure(None)
#
#@rule('struct-union-header = UNION IDENTIFIER')
#@rule('struct-union-header = UNION TYPE')
#def on_named_union_header(lineno, st, name):
#    union_space[name] = union = union_space.get(name, Union(None))
#    return union
#
#@rule('struct-union-header = STRUCT IDENTIFIER')
#@rule('struct-union-header = STRUCT TYPE')
#def on_named_struct_header(lineno, st, name):
#    struct_space[name] = struct = struct_space.get(name, Structure(None))
#    return struct
#
#@rule('type-sign = CONST type-sign')
#def on_const(lineno, con, typesign):
#    return ('CONST', typesign)
#
#@rule('type-pointer = type-pointer STAR')
#@rule('type-pointer = type-pointer STAR CONST')
#def on_pointer_type(lineno, typesign, st, *con):
#    return Pointer(typesign)
#
#@rule('type-sign = type-pointer')
#@rule('type-pointer = type-term')
#def on_passthrough(lineno, typesign):
#    return typesign
#
#@rule('enum-header = ENUM')
#@rule('enum-header = ENUM IDENTIFIER')
#def on_enum(lineno, enum, *idents):
#    for ident in idents:
#        enum_space[ident] = prim_space['enum']
#    return prim_space['enum']
#
#@rule('by-the-way = enum-header LEFT_BRACE enum-list RIGHT_BRACE SEMICOLON')
#@rule('type-term = enum-header LEFT_BRACE enum-list RIGHT_BRACE')
#def on_enum(lineno, enum, lb, lists, rb, *blah):
#    for name, value in lists:
#        pass
#    return enum
#
#@rule('enum-name = IDENTIFIER')
#def on_enum_name(lineno, name):
#    return (name, None)
#
#@rule('enum-name = IDENTIFIER EQUAL const-expression')
#def on_enum_name(lineno, name, eq, value):
#    return (name, value)
#
#@rule('by-the-way = struct-union-header LEFT_BRACE struct-list RIGHT_BRACE SEMICOLON')
#@rule('type-term = struct-union-header LEFT_BRACE struct-list RIGHT_BRACE')
#def on_structure(lineno, struct, lb, fields, rb, *blah):
#    struct.fields = fields
#    return struct
#
#@rule('type-term = STRUCT IDENTIFIER')
#@rule('type-term = STRUCT TYPE')
#def on_struct_identifier(lineno, st, name):
#    struct_space[name] = struct = struct_space.get(name, Structure(None))
#    return struct
#
#@rule('type-term = UNION IDENTIFIER')
#@rule('type-term = UNION TYPE')
#def on_struct_identifier(lineno, st, ident):
#    return union_space[ident]
#
#@rule('type-term = TYPE')
#@rule('type-term = VOID')
##@rule('type-term = CHAR')
#def on_type_primitive(lineno, typesign):
#    return type_space[typesign]
#
#@rule('type-term = FLOAT')
#@rule('type-term = DOUBLE')
#@rule('type-term = LONG DOUBLE')
#def on_type_flonum(lineno, *flonum):
#    return prim_space[' '.join(flonum)]
#
#@rule('type-term = type-integer')
#def on_type_integer(lineno, typesign):
#    return typesign
#
#@rule('type-integer = UNSIGNED type-combination')
#def on_unsigned(lineno, un, prim):
#    return Unsigned(prim_space[prim].size)
#
#@rule('type-integer = SIGNED type-combination')
#def on_signed(lineno, un, prim):
#    return Unsigned(prim_space[prim].size)
#
#@rule('type-integer = type-combination')
#def on_int_default(lineno, prim):
#    return prim_space[prim]

result = canonical.simulate(rules, 'translation_unit')

attribute_conflict = set([labelled_rules['storage_attribute'], labelled_rules['declarator_attribute']])

remaining_conflicts = []
for row, name, group in result.conflicts:
    if group == attribute_conflict:
        result.table[row][name] = labelled_rules['declarator_attribute']
        continue
    remaining_conflicts.append((row, name, group))
result.conflicts = remaining_conflicts
assert len(result.conflicts) == 0, lrkit.diagnose(result)
print 'parsing'
table = result.table

def step(lineno, group, value):
    global state
    if group == 'IDENTIFIER' and value in type_space:
        group = 'TYPE_NAME'
    action = table[state].get(group, table[state].get('*'))
    while isinstance(action, Rule):
        values = []
        for i in range(len(action)):
            state = stack.pop(-1)
            values.append(data.pop(-1))
        values.reverse()
        stack.append(state)
        data.append(action.func(lineno, *values))
        state = table[state][action.lhs]

        if group == 'IDENTIFIER' and value in type_space:
            group = 'TYPE_NAME'
        action = table[state].get(group, table[state].get('*'))
    if action is None:
        raise Exception("%i: got %s, but expected %s: %s" % (lineno, group, ', '.join(map(str, table[state])), value))
    if isinstance(action, Accept):
        state  = stack.pop(-1)
        result = data.pop(-1)
        return result
    else:
        stack.append(state)
        data.append(value)
        state = action

attributes = []
#proc = Popen(['gcc', '-E', argv[1]], stdout=PIPE)
#print proc.stdout.read()

logs = open('logfile', 'a')
for path in argv[1:]:
    try:
        reset_env()
        state = 0
        stack = []
        data  = []
        headers = check_output(['gcc', '-E', path])
        token_stream = tokenize(headers)
        for lineno, group, value in token_stream:
            if group == 'MACRO':
                continue
            step(lineno, group, value)
        result = step(lineno, None, None)
    except Exception, error:
        print error
        logs.write("%s:%s\n" % (path, error))
    else:
        print "success", path
logs.close()

#macros = check_output(['gcc', '-dM', '-E', path])
#macroregex = re.compile(r"(\w+(\([^\)]*\))?)\W*(.*)")
#for line in [macro.strip() for macro in macros.split('#define')]:
#    if line == "":
#        continue
#    match = macroregex.match(line)
#    name, arglist, value = match.groups()
